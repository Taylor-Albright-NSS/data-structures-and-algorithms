INTRODUCTION TO STACKS - THE BOOK RETURN SYSTEM

Must start with a stack class that contains methods for the stack operations: push, pop, peek, isEmpty, size
Here is a good deafult stack example:

class Stack {
	constructor() {
		this.items = []
	}
	push(item) {
		this.items.push(item)
	}
	pop() {
		if (this.isEmpty()) throw new Error('Stack is empty - cannot pop')
		return this.items.pop()
	}
	peek() {
		if (this.isEmpty()) throw new Error('Stack is empty - cannot peek')
		return this.items[this.items.length - 1]
	}
	isEmpty() {
		return this.items.length === 0
	}
	size() {
		return this.items.length
	}
}

Must start with a queue class that contains methods for the queue operations: enqueue, dequeue, peek, isEmpty, size
Here is a good deafult queue example:

QUEUES
class Queue {
	constructor() {
		this.items = []
	}
	enqueue(item) {
		this.items.push(item)
	}
	dequeue() {
		if (this.isEmpty()) throw new Error('Queue is empty - cannot dequeue')
		return this.items.shift()
	}
	peek() {
		if (this.isEmpty()) throw new Error('Queue is empty - cannot peek')
		return this.items[0]
	}
	isEmpty() {
		return this.items.length === 0
	}
	size() {
		return this.items.length
	}
}

IMPLEMENTATION TRADEOFFS
Array-Based Stack - Perfect for book returns - simple and fast

class BookReturnStack {
  constructor() {
    this.books = [];
  }
  
  addReturn(book) {
    this.books.push(book);           // O(1)
  }
  
  processNext() {
    return this.books.pop();         // O(1)
  }
  
  // Why this works well:
  // - LIFO matches physical book stacking
  // - All operations are O(1)
  // - Simple to implement and maintain
  // - Natural behavior for staff
}

Circular Array Queue - Optimal for hold requests - fast and fair
class HoldRequestQueue {
  constructor(capacity = 100) {
    this.requests = new Array(capacity);
    this.front = 0;
    this.rear = 0;
    this.size = 0;
    this.capacity = capacity;
  }
  
  addRequest(request) {
    if (this.isFull()) this.resize();
    this.requests[this.rear] = request;
    this.rear = (this.rear + 1) % this.capacity;  // O(1)
    this.size++;
  }
  
  processNext() {
    if (this.isEmpty()) return null;
    const request = this.requests[this.front];
    this.requests[this.front] = null;
    this.front = (this.front + 1) % this.capacity; // O(1)
    this.size--;
    return request;
  }
  
  // Why this works well:
  // - FIFO ensures fairness
  // - All operations are O(1)
  // - Scales well with volume
  // - Memory efficient
}

Alternative approach: Linked List Queue - dynamic sizing
class LinkedListQueue {
  constructor() {
    this.front = null;
    this.rear = null;
    this.size = 0;
  }
  
  addRequest(request) {
    const node = { data: request, next: null };
    if (this.isEmpty()) {
      this.front = node;
    } else {
      this.rear.next = node;
    }
    this.rear = node;
    this.size++;                     // O(1)
  }
  
  processNext() {
    if (this.isEmpty()) return null;
    const request = this.front.data;
    this.front = this.front.next;
    if (!this.front) this.rear = null;
    this.size--;
    return request;                  // O(1)
  }
  
  // Pros: Dynamic sizing, no capacity limits
  // Cons: More memory overhead, pointer management
}


