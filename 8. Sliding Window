SLIDING WINDOW

There are 2 forms of sliding window: fixed and variable

FIXED SIZE SLIDING WINDOW

function calculateSMA(prices, period) {
  if (prices.length < period) return [];
  
  const smaValues = [];
  
  // Calculate sum of first window
  let windowSum = 0;
  for (let i = 0; i < period; i++) {
    windowSum += prices[i];
  }
  
  // Add first SMA value
  smaValues.push(Number((windowSum / period).toFixed(1)));
  
  // Slide window through remaining data
  for (let i = period; i < prices.length; i++) {
    // Remove oldest price, add newest price
    windowSum = windowSum - prices[i - period] + prices[i];
    smaValues.push(Number((windowSum / period).toFixed(1)));
  }
  
  return smaValues;
}

Breakdown:
  1. Defensive code
    if (prices.length < period) return [];

    If prices.length is less than period, that means there wouldn't be enough prices
    in the list to fill the sliding window. If prices.length = 3 and period = 4, it would essentially 
    look like [3, 8, 3, undefined]


  2. Calculate sum of first window
    let windowSum = 0;
    for (let i = 0; i < period; i++) {
        windowSum += prices[i];
    }

  3. Add first SMA value
    smaValues.push(Number((windowSum / period).toFixed(1)));

  4. Slide window through remaining data
  for (let i = period; i < prices.length; i++) {
    // Subtract the number that's leaving the window, and add the new number that's entering
    // In this case, we're subtracting prices[i - period] which is prices[0] on the first iteration
    // We then add to the end of the window the new value prices[i] which is prices[period] on the first iteration
    windowSum = windowSum - prices[i - period] + prices[i];
    smaValues.push(Number((windowSum / period).toFixed(1)));
  }




VARIABLE SIZE SLIDING WINDOW: Shortest period

function quickestProfitTarget(profits, target) {
  let left = 0;        // start of window
  let sum = 0;         // running sum of current window
  let minLen = Infinity; // track best (smallest) window length

  Expand the window one day at a time
  for (let right = 0; right < profits.length; right++) {
    sum += profits[right];

    Once we’ve reached the target, try to shrink from the left
    Shrinking keeps it valid while removing extra "baggage" days
    while (sum >= target) {
      minLen = Math.min(minLen, right - left + 1); // update best length
      sum -= profits[left++]; // shrink from left
    }
  }

  // If never reached target, return 0
  return minLen === Infinity ? 0 : minLen;
}

// Example: How quickly can we reach $7 profit?
console.log(quickestProfitTarget([2, 3, 1, 2, 4, 3], 7));
// → 2  (profits [4,3] reach $7 in just 2 days)


BREAKDOWN OF THE ABOVE FUNCTION

profits = [2, 3, 1, 2, 4, 3], target = 7

left = 0, right = 0, sum = 0, minLen = Infinity

right = 0 (profit = 2)
Window: [2]
sum = 2 < 7 → do not shrink

right = 1 (profit = 3)
Window: [2, 3]
sum = 5 < 7 → do not shrink

right = 2 (profit = 1)
Window: [2, 3, 1]
sum = 6 < 7 → do not shrink

right = 3 (profit = 2)
Window: [2, 3, 1, 2]
sum = 8 >= 7 → shrink from left
  minLen = right - left + 1 = 4
  sum -= profits[left] → sum = 8 - 2 = 6
  left = 1 -> Left increments to shorten the window
Window after shrinking: [3, 1, 2], sum = 6 < 7 → stop shrinking

Window: [3, 1, 2, 4]
sum = 10 >= 7 → shrink from left
  minLen = min(4, 4) = 4
  sum -= profits[left] → sum = 10 - 3 = 7
  left = 2
  sum >= 7 → shrink again
    minLen = min(4, 3) = 3
    sum -= profits[left] → sum = 7 - 1 = 6
    left = 3
Window after shrinking: [2, 4], sum = 6 < 7 → stop shrinking

Window: [2, 4, 3]
sum = 9 >= 7 → shrink from left
  minLen = min(3, 3) = 3
  sum -= profits[left] → sum = 9 - 2 = 7
  left = 4
  sum >= 7 → shrink again
    minLen = min(3, 2) = 2
    sum -= profits[left] → sum = 7 - 4 = 3
    left = 5
Window after shrinking: [3], sum = 3 < 7 → stop shrinking

Shortest window length where cumulative profit >= 7 → minLen = 2
Window: [4, 3]


VARIABLE SIZE SLIDING WINDOW: Longest period - Find the longest consecutive streak of non-decresing values

/*
Problem: Find Longest Period with Consistent Growth

Complete solution using variable-size sliding window to find
the longest consecutive period of non-decreasing portfolio values.
*/

function findLongestGrowthPeriod(portfolioValues) {
  if (portfolioValues.length <= 1) return { startDay: 0, endDay: 0, length: portfolioValues.length };
  
  let maxLength = 1;
  let bestPeriod = { startDay: 0, endDay: 0, length: 1 };
  let currentStart = 0;
  
  for (let i = 1; i < portfolioValues.length; i++) {
    if (portfolioValues[i] < portfolioValues[i - 1]) {
      const currentLength = i - currentStart;
      if (currentLength > maxLength) {
        maxLength = currentLength;
        bestPeriod = {
          startDay: currentStart,
          endDay: i - 1,
          length: currentLength
        };
      }
      
      // Reset window start to current position
      currentStart = i;
    }
  }
  
  const finalLength = portfolioValues.length - currentStart;
  if (finalLength > maxLength) {
    bestPeriod = {
      startDay: currentStart,
      endDay: portfolioValues.length - 1,
      length: finalLength
    };
  }
  
  return bestPeriod;
}

// Test the implementation
const testValues = [100, 102, 105, 103, 107, 110, 115, 112, 118, 120];
console.log("Longest growth period:", findLongestGrowthPeriod(testValues));